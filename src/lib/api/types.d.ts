/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns basic details about the server.
         *
         * @description Returns basic details about the server as well as your authentication status.
         *
         *     This is the only API request that does *not* require authentication.
         *
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Success */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            /** @description Is your current request authenticated? */
                            authenticated?: boolean;
                            /** @description 'OK' */
                            ok?: string;
                            /** @description 'Obsidian Local REST API' */
                            service?: string;
                            versions?: {
                                /** @description Obsidian plugin API version */
                                obsidian?: string;
                                /** @description Plugin version. */
                                self?: string;
                            };
                        };
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/active/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Return the content of the active file open in Obsidian.
         *
         * @description Returns the content of the currently active file in Obsidian.
         *
         *     If you specify the header `Accept: application/vnd.olrapi.note+json`, will return a JSON representation of your note including parsed tag and frontmatter data as well as filesystem metadata.  See "responses" below for details.
         *
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Success */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/vnd.olrapi.note+json": components["schemas"]["NoteJson"];
                        "text/markdown": string;
                    };
                };
                /** @description File does not exist */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        /** Update the content of the active file open in Obsidian.
         *      */
        put: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            /** @description Content of the file you would like to upload. */
            requestBody: {
                content: {
                    "*/*": string;
                    "text/markdown": string;
                };
            };
            responses: {
                /** @description Success */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Incoming file could not be processed.  Make sure you have specified a reasonable file name, and make sure you have set a reasonable 'Content-Type' header; if you are uploading a note, 'text/markdown' is likely the right choice.
                 *      */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
                /** @description Your path references a directory instead of a file; this request method is valid only for updating files.
                 *      */
                405: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
            };
        };
        /**
         * Append content to the active file open in Obsidian.
         *
         * @description Appends content to the end of the currently-open note.
         *
         *     If you would like to insert text relative to a particular heading instead of appending to the end of the file, see 'patch'.
         *
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            /** @description Content you would like to append. */
            requestBody: {
                content: {
                    "text/markdown": string;
                };
            };
            responses: {
                /** @description Success */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Bad Request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
                /** @description Your path references a directory instead of a file; this request method is valid only for updating files.
                 *      */
                405: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
            };
        };
        /** Deletes the currently-active file in Obsidian.
         *      */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Success */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description File does not exist. */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
                /** @description Your path references a directory instead of a file; this request method is valid only for updating files.
                 *      */
                405: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
            };
        };
        options?: never;
        head?: never;
        /**
         * Insert content into the currently open note in Obsidian relative to a heading within that document.
         *
         * @description Inserts content into the currently-open note relative to a heading within that note.
         *
         *     Allows you to modify the content relative to a heading, block reference, or frontmatter field in your document.
         *
         *     Note that this API was changed in Version 3.0 of this extension and the earlier PATCH API is now deprecated. Requests made using the previous version of this API will continue to work until Version 4.0 is released.  See https://github.com/coddingtonbear/obsidian-local-rest-api/wiki/Changes-to-PATCH-requests-between-versions-2.0-and-3.0 for more details and migration instructions.
         *
         *     # Examples
         *
         *     All of the below examples assume you have a document that looks like
         *     this:
         *
         *     ```markdown
         *     ---
         *     alpha: 1
         *     beta: test
         *     delta:
         *     zeta: 1
         *     yotta: 1
         *     gamma:
         *     - one
         *     - two
         *     ---
         *
         *     # Heading 1
         *
         *     This is the content for heading one
         *
         *     Also references some [[#^484ef2]]
         *
         *     ## Subheading 1:1
         *     Content for Subheading 1:1
         *
         *     ### Subsubheading 1:1:1
         *
         *     ### Subsubheading 1:1:2
         *
         *     Testing how block references work for a table.[[#^2c7cfa]]
         *     Some content for Subsubheading 1:1:2
         *
         *     More random text.
         *
         *     ^2d9b4a
         *
         *     ## Subheading 1:2
         *
         *     Content for Subheading 1:2.
         *
         *     some content with a block reference ^484ef2
         *
         *     ## Subheading 1:3
         *     | City         | Population |
         *     | ------------ | ---------- |
         *     | Seattle, WA  | 8          |
         *     | Portland, OR | 4          |
         *
         *     ^2c7cfa
         *     ```
         *
         *     ## Append Content Below a Heading
         *
         *     If you wanted to append the content "Hello" below "Subheading 1:1:1" under "Heading 1",
         *     you could send a request with the following headers:
         *
         *     - `Operation`: `append`
         *     - `Target-Type`: `heading`
         *     - `Target`: `Heading 1::Subheading 1:1:1`
         *     - with the request body: `Hello`
         *
         *     The above would work just fine for `prepend` or `replace`, too, of course,
         *     but with different results.
         *
         *     ## Append Content to a Block Reference
         *
         *     If you wanted to append the content "Hello" below the block referenced by
         *     "2d9b4a" above ("More random text."), you could send the following headers:
         *
         *     - `Operation`: `append`
         *     - `Target-Type`: `block`
         *     - `Target`: `2d9b4a`
         *     - with the request body: `Hello`
         *
         *     The above would work just fine for `prepend` or `replace`, too, of course,
         *     but with different results.
         *
         *     ## Add a Row to a Table Referenced by a Block Reference
         *
         *     If you wanted to add a new city ("Chicago, IL") and population ("16") pair to the table above
         *     referenced by the block reference `2c7cfa`, you could send the following
         *     headers:
         *
         *     - `Operation`: `append`
         *     - `TargetType`: `block`
         *     - `Target`: `2c7cfa`
         *     - `Content-Type`: `application/json`
         *     - with the request body: `[["Chicago, IL", "16"]]`
         *
         *     The use of a `Content-Type` of `application/json` allows the API
         *     to infer that member of your array represents rows and columns of your
         *     to append to the referenced table.  You can of course just use a
         *     `Content-Type` of `text/markdown`, but in such a case you'll have to
         *     format your table row manually instead of letting the library figure
         *     it out for you.
         *
         *     You also have the option of using `prepend` (in which case, your new
         *     row would be the first -- right below the table heading) or `replace` (in which
         *     case all rows except the table heading would be replaced by the new row(s)
         *     you supplied).
         *
         *     ## Setting a Frontmatter Field
         *
         *     If you wanted to set the frontmatter field `alpha` to `2`, you could
         *     send the following headers:
         *
         *     - `Operation`: `replace`
         *     - `TargetType`: `frontmatter`
         *     - `Target`: `beep`
         *     - with the request body `2`
         *
         *     If you're setting a frontmatter field that might not already exist
         *     you may want to use the `Create-Target-If-Missing` header so the
         *     new frontmatter field is created and set to your specified value
         *     if it doesn't already exist.
         *
         *     You may find using a `Content-Type` of `application/json` to be
         *     particularly useful in the case of frontmatter since frontmatter
         *     fields' values are JSON data, and the API can be smarter about
         *     interpreting yoru `prepend` or `append` requests if you specify
         *     your data as JSON (particularly when appending, for example,
         *     list items).
         *
         */
        patch: {
            parameters: {
                query?: never;
                header: {
                    /** @description Patch operation to perform */
                    Operation: "append" | "prepend" | "replace";
                    /** @description Type of target to patch */
                    "Target-Type": "heading" | "block" | "frontmatter";
                    /** @description Delimiter to use for nested targets (i.e. Headings) */
                    "Target-Delimiter"?: string;
                    /** @description Target to patch; this value can be URL-Encoded and *must*
                     *     be URL-Encoded if it includes non-ASCII characters.
                     *      */
                    Target: string;
                    /** @description Trim whitespace from Target before applying patch? */
                    "Trim-Target-Whitespace"?: "true" | "false";
                };
                path?: never;
                cookie?: never;
            };
            /** @description Content you would like to insert. */
            requestBody: {
                content: {
                    "application/json": string;
                    "text/markdown": string;
                };
            };
            responses: {
                /** @description Success */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Bad Request; see response message for details. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
                /** @description Does not exist */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
                /** @description Your path references a directory instead of a file; this request method is valid only for updating files.
                 *      */
                405: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
            };
        };
        trace?: never;
    };
    "/commands/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a list of available commands.
         *      */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description A list of available commands. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            commands?: {
                                id?: string;
                                name?: string;
                            }[];
                        };
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/commands/{commandId}/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Execute a command.
         *      */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The id of the command to execute */
                    commandId: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Success */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description The command you specified does not exist. */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/open/{filename}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Open the specified document in Obsidian
         *
         * @description Opens the specified document in Obsidian.
         *
         *     Note: Obsidian will create a new document at the path you have
         *     specified if such a document did not already exist.
         *
         */
        post: {
            parameters: {
                query?: {
                    /** @description Open this as a new leaf? */
                    newLeaf?: boolean;
                };
                header?: never;
                path: {
                    /** @description Path to the file to return (relative to your vault root).
                     *      */
                    filename: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Success */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/periodic/{period}/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get current periodic note for the specified period.
         *      */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The name of the period for which you would like to grab the current note. */
                    period: "daily" | "weekly" | "monthly" | "quarterly" | "yearly";
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Success */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/vnd.olrapi.note+json": components["schemas"]["NoteJson"];
                        "text/markdown": string;
                    };
                };
                /** @description File does not exist */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        /** Update the content of a periodic note.
         *      */
        put: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The name of the period for which you would like to grab the current note. */
                    period: "daily" | "weekly" | "monthly" | "quarterly" | "yearly";
                };
                cookie?: never;
            };
            /** @description Content of the file you would like to upload. */
            requestBody: {
                content: {
                    "*/*": string;
                    "text/markdown": string;
                };
            };
            responses: {
                /** @description Success */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Incoming file could not be processed.  Make sure you have specified a reasonable file name, and make sure you have set a reasonable 'Content-Type' header; if you are uploading a note, 'text/markdown' is likely the right choice.
                 *      */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
                /** @description Your path references a directory instead of a file; this request method is valid only for updating files.
                 *      */
                405: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
            };
        };
        /**
         * Append content to a periodic note.
         *
         * @description Appends content to the periodic note for the specified period.  This will create the relevant periodic note if necessary.
         *
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The name of the period for which you would like to grab the current note. */
                    period: "daily" | "weekly" | "monthly" | "quarterly" | "yearly";
                };
                cookie?: never;
            };
            /** @description Content you would like to append. */
            requestBody: {
                content: {
                    "text/markdown": string;
                };
            };
            responses: {
                /** @description Success */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Bad Request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
                /** @description Your path references a directory instead of a file; this request method is valid only for updating files.
                 *      */
                405: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
            };
        };
        /**
         * Delete a periodic note.
         *
         * @description Deletes the periodic note for the specified period.
         *
         */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description The name of the period for which you would like to grab the current note. */
                    period: "daily" | "weekly" | "monthly" | "quarterly" | "yearly";
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Success */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description File does not exist. */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
                /** @description Your path references a directory instead of a file; this request method is valid only for updating files.
                 *      */
                405: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
            };
        };
        options?: never;
        head?: never;
        /**
         * Insert content into a periodic note relative to a heading within that document.
         *
         * @description Inserts content into an existing note relative to a heading within your note.
         *
         *     Allows you to modify the content relative to a heading, block reference, or frontmatter field in your document.
         *
         *     Note that this API was changed in Version 3.0 of this extension and the earlier PATCH API is now deprecated. Requests made using the previous version of this API will continue to work until Version 4.0 is released.  See https://github.com/coddingtonbear/obsidian-local-rest-api/wiki/Changes-to-PATCH-requests-between-versions-2.0-and-3.0 for more details and migration instructions.
         *
         *     # Examples
         *
         *     All of the below examples assume you have a document that looks like
         *     this:
         *
         *     ```markdown
         *     ---
         *     alpha: 1
         *     beta: test
         *     delta:
         *     zeta: 1
         *     yotta: 1
         *     gamma:
         *     - one
         *     - two
         *     ---
         *
         *     # Heading 1
         *
         *     This is the content for heading one
         *
         *     Also references some [[#^484ef2]]
         *
         *     ## Subheading 1:1
         *     Content for Subheading 1:1
         *
         *     ### Subsubheading 1:1:1
         *
         *     ### Subsubheading 1:1:2
         *
         *     Testing how block references work for a table.[[#^2c7cfa]]
         *     Some content for Subsubheading 1:1:2
         *
         *     More random text.
         *
         *     ^2d9b4a
         *
         *     ## Subheading 1:2
         *
         *     Content for Subheading 1:2.
         *
         *     some content with a block reference ^484ef2
         *
         *     ## Subheading 1:3
         *     | City         | Population |
         *     | ------------ | ---------- |
         *     | Seattle, WA  | 8          |
         *     | Portland, OR | 4          |
         *
         *     ^2c7cfa
         *     ```
         *
         *     ## Append Content Below a Heading
         *
         *     If you wanted to append the content "Hello" below "Subheading 1:1:1" under "Heading 1",
         *     you could send a request with the following headers:
         *
         *     - `Operation`: `append`
         *     - `Target-Type`: `heading`
         *     - `Target`: `Heading 1::Subheading 1:1:1`
         *     - with the request body: `Hello`
         *
         *     The above would work just fine for `prepend` or `replace`, too, of course,
         *     but with different results.
         *
         *     ## Append Content to a Block Reference
         *
         *     If you wanted to append the content "Hello" below the block referenced by
         *     "2d9b4a" above ("More random text."), you could send the following headers:
         *
         *     - `Operation`: `append`
         *     - `Target-Type`: `block`
         *     - `Target`: `2d9b4a`
         *     - with the request body: `Hello`
         *
         *     The above would work just fine for `prepend` or `replace`, too, of course,
         *     but with different results.
         *
         *     ## Add a Row to a Table Referenced by a Block Reference
         *
         *     If you wanted to add a new city ("Chicago, IL") and population ("16") pair to the table above
         *     referenced by the block reference `2c7cfa`, you could send the following
         *     headers:
         *
         *     - `Operation`: `append`
         *     - `TargetType`: `block`
         *     - `Target`: `2c7cfa`
         *     - `Content-Type`: `application/json`
         *     - with the request body: `[["Chicago, IL", "16"]]`
         *
         *     The use of a `Content-Type` of `application/json` allows the API
         *     to infer that member of your array represents rows and columns of your
         *     to append to the referenced table.  You can of course just use a
         *     `Content-Type` of `text/markdown`, but in such a case you'll have to
         *     format your table row manually instead of letting the library figure
         *     it out for you.
         *
         *     You also have the option of using `prepend` (in which case, your new
         *     row would be the first -- right below the table heading) or `replace` (in which
         *     case all rows except the table heading would be replaced by the new row(s)
         *     you supplied).
         *
         *     ## Setting a Frontmatter Field
         *
         *     If you wanted to set the frontmatter field `alpha` to `2`, you could
         *     send the following headers:
         *
         *     - `Operation`: `replace`
         *     - `TargetType`: `frontmatter`
         *     - `Target`: `beep`
         *     - with the request body `2`
         *
         *     If you're setting a frontmatter field that might not already exist
         *     you may want to use the `Create-Target-If-Missing` header so the
         *     new frontmatter field is created and set to your specified value
         *     if it doesn't already exist.
         *
         *     You may find using a `Content-Type` of `application/json` to be
         *     particularly useful in the case of frontmatter since frontmatter
         *     fields' values are JSON data, and the API can be smarter about
         *     interpreting yoru `prepend` or `append` requests if you specify
         *     your data as JSON (particularly when appending, for example,
         *     list items).
         *
         */
        patch: {
            parameters: {
                query?: never;
                header: {
                    /** @description Patch operation to perform */
                    Operation: "append" | "prepend" | "replace";
                    /** @description Type of target to patch */
                    "Target-Type": "heading" | "block" | "frontmatter";
                    /** @description Delimiter to use for nested targets (i.e. Headings) */
                    "Target-Delimiter"?: string;
                    /** @description Target to patch; this value can be URL-Encoded and *must*
                     *     be URL-Encoded if it includes non-ASCII characters.
                     *      */
                    Target: string;
                    /** @description Trim whitespace from Target before applying patch? */
                    "Trim-Target-Whitespace"?: "true" | "false";
                };
                path: {
                    /** @description The name of the period for which you would like to grab the current note. */
                    period: "daily" | "weekly" | "monthly" | "quarterly" | "yearly";
                };
                cookie?: never;
            };
            /** @description Content you would like to insert. */
            requestBody: {
                content: {
                    "application/json": string;
                    "text/markdown": string;
                };
            };
            responses: {
                /** @description Success */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Bad Request; see response message for details. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
                /** @description Does not exist */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
                /** @description Your path references a directory instead of a file; this request method is valid only for updating files.
                 *      */
                405: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
            };
        };
        trace?: never;
    };
    "/search/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search for documents matching a specified search query
         *
         * @description Evaluates a provided query against each file in your vault.
         *
         *     This endpoint supports multiple query formats.  Your query should be specified in your request's body, and will be interpreted according to the `Content-type` header you specify from the below options.Additional query formats may be added in the future.
         *
         *     # Dataview DQL (`application/vnd.olrapi.dataview.dql+txt`)
         *
         *     Accepts a `TABLE`-type Dataview query as a text string.  See [Dataview](https://blacksmithgu.github.io/obsidian-dataview/query/queries/)'s query documentation for information on how to construct a query.
         *
         *     # JsonLogic (`application/vnd.olrapi.jsonlogic+json`)
         *
         *     Accepts a JsonLogic query specified as JSON.  See [JsonLogic](https://jsonlogic.com/operations.html)'s documentation for information about the base set of operators available, but in addition to those operators the following operators are available:
         *
         *     - `glob: [PATTERN, VALUE]`: Returns `true` if a string matches a glob pattern.  E.g.: `{"glob": ["*.foo", "bar.foo"]}` is `true` and `{"glob": ["*.bar", "bar.foo"]}` is `false`.
         *     - `regexp: [PATTERN, VALUE]`: Returns `true` if a string matches a regular expression.  E.g.: `{"regexp": [".*\.foo", "bar.foo"]` is `true` and `{"regexp": [".*\.bar", "bar.foo"]}` is `false`.
         *
         *     Returns only non-falsy results.  "Non-falsy" here treats the following values as "falsy":
         *
         *     - `false`
         *     - `null` or `undefined`
         *     - `0`
         *     - `[]`
         *     - `{}`
         *
         *     Files are represented as an object having the schema described
         *     in the Schema named 'NoteJson' at the bottom of this page.
         *     Understanding the shape of a JSON object from a schema can be
         *     tricky; so you may find it helpful to examine the generated metadata
         *     for individual files in your vault to understand exactly what values
         *     are returned.  To see that, access the `GET` `/vault/{filePath}`
         *     route setting the header:
         *     `Accept: application/vnd.olrapi.note+json`.  See examples below
         *     for working examples of queries performing common search operations.
         *
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/vnd.olrapi.dataview.dql+txt": Record<string, never>;
                    "application/vnd.olrapi.jsonlogic+json": Record<string, never>;
                };
            };
            responses: {
                /** @description Success */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            /** @description Path to the matching file */
                            filename: string;
                            result: string | number | unknown[] | Record<string, never> | boolean;
                        }[];
                    };
                };
                /** @description Bad request.  Make sure you have specified an acceptable
                 *     Content-Type for your search query.
                 *      */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/search/simple/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Search for documents matching a specified text query
         *      */
        post: {
            parameters: {
                query: {
                    /** @description Your search query */
                    query: string;
                    /** @description How much context to return around the matching string */
                    contextLength?: number;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Success */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            /** @description Path to the matching file */
                            filename?: string;
                            matches?: {
                                context: string;
                                match: {
                                    end: number;
                                    start: number;
                                };
                            }[];
                            score?: number;
                        }[];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/vault/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List files that exist in the root of your vault.
         *
         * @description Lists files in the root directory of your vault.
         *
         *     Note: that this is exactly the same API endpoint as the below "List files that exist in the specified directory." and exists here only due to a quirk of this particular interactive tool.
         *
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Success */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            files?: string[];
                        };
                    };
                };
                /** @description Directory does not exist */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/vault/{filename}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Return the content of a single file in your vault.
         *
         * @description Returns the content of the file at the specified path in your vault should the file exist.
         *
         *     If you specify the header `Accept: application/vnd.olrapi.note+json`, will return a JSON representation of your note including parsed tag and frontmatter data as well as filesystem metadata.  See "responses" below for details.
         *
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Path to the relevant file (relative to your vault root).
                     *      */
                    filename: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Success */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/vnd.olrapi.note+json": components["schemas"]["NoteJson"];
                        "text/markdown": string;
                    };
                };
                /** @description File does not exist */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        /**
         * Create a new file in your vault or update the content of an existing one.
         *
         * @description Creates a new file in your vault or updates the content of an existing one if the specified file already exists.
         *
         */
        put: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Path to the relevant file (relative to your vault root).
                     *      */
                    filename: string;
                };
                cookie?: never;
            };
            /** @description Content of the file you would like to upload. */
            requestBody: {
                content: {
                    "*/*": string;
                    "text/markdown": string;
                };
            };
            responses: {
                /** @description Success */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Incoming file could not be processed.  Make sure you have specified a reasonable file name, and make sure you have set a reasonable 'Content-Type' header; if you are uploading a note, 'text/markdown' is likely the right choice.
                 *      */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
                /** @description Your path references a directory instead of a file; this request method is valid only for updating files.
                 *      */
                405: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
            };
        };
        /**
         * Append content to a new or existing file.
         *
         * @description Appends content to the end of an existing note. If the specified file does not yet exist, it will be created as an empty file.
         *
         *     If you would like to insert text relative to a particular heading instead of appending to the end of the file, see 'patch'.
         *
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Path to the relevant file (relative to your vault root).
                     *      */
                    filename: string;
                };
                cookie?: never;
            };
            /** @description Content you would like to append. */
            requestBody: {
                content: {
                    "text/markdown": string;
                };
            };
            responses: {
                /** @description Success */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Bad Request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
                /** @description Your path references a directory instead of a file; this request method is valid only for updating files.
                 *      */
                405: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
            };
        };
        /** Delete a particular file in your vault.
         *      */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Path to the relevant file (relative to your vault root).
                     *      */
                    filename: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Success */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description File does not exist. */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
                /** @description Your path references a directory instead of a file; this request method is valid only for updating files.
                 *      */
                405: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
            };
        };
        options?: never;
        head?: never;
        /**
         * Insert content into an existing note relative to a heading within that document.
         *
         * @description Inserts content into an existing note relative to a heading within your note.
         *
         *     Allows you to modify the content relative to a heading, block reference, or frontmatter field in your document.
         *
         *     Note that this API was changed in Version 3.0 of this extension and the earlier PATCH API is now deprecated. Requests made using the previous version of this API will continue to work until Version 4.0 is released.  See https://github.com/coddingtonbear/obsidian-local-rest-api/wiki/Changes-to-PATCH-requests-between-versions-2.0-and-3.0 for more details and migration instructions.
         *
         *     # Examples
         *
         *     All of the below examples assume you have a document that looks like
         *     this:
         *
         *     ```markdown
         *     ---
         *     alpha: 1
         *     beta: test
         *     delta:
         *     zeta: 1
         *     yotta: 1
         *     gamma:
         *     - one
         *     - two
         *     ---
         *
         *     # Heading 1
         *
         *     This is the content for heading one
         *
         *     Also references some [[#^484ef2]]
         *
         *     ## Subheading 1:1
         *     Content for Subheading 1:1
         *
         *     ### Subsubheading 1:1:1
         *
         *     ### Subsubheading 1:1:2
         *
         *     Testing how block references work for a table.[[#^2c7cfa]]
         *     Some content for Subsubheading 1:1:2
         *
         *     More random text.
         *
         *     ^2d9b4a
         *
         *     ## Subheading 1:2
         *
         *     Content for Subheading 1:2.
         *
         *     some content with a block reference ^484ef2
         *
         *     ## Subheading 1:3
         *     | City         | Population |
         *     | ------------ | ---------- |
         *     | Seattle, WA  | 8          |
         *     | Portland, OR | 4          |
         *
         *     ^2c7cfa
         *     ```
         *
         *     ## Append Content Below a Heading
         *
         *     If you wanted to append the content "Hello" below "Subheading 1:1:1" under "Heading 1",
         *     you could send a request with the following headers:
         *
         *     - `Operation`: `append`
         *     - `Target-Type`: `heading`
         *     - `Target`: `Heading 1::Subheading 1:1:1`
         *     - with the request body: `Hello`
         *
         *     The above would work just fine for `prepend` or `replace`, too, of course,
         *     but with different results.
         *
         *     ## Append Content to a Block Reference
         *
         *     If you wanted to append the content "Hello" below the block referenced by
         *     "2d9b4a" above ("More random text."), you could send the following headers:
         *
         *     - `Operation`: `append`
         *     - `Target-Type`: `block`
         *     - `Target`: `2d9b4a`
         *     - with the request body: `Hello`
         *
         *     The above would work just fine for `prepend` or `replace`, too, of course,
         *     but with different results.
         *
         *     ## Add a Row to a Table Referenced by a Block Reference
         *
         *     If you wanted to add a new city ("Chicago, IL") and population ("16") pair to the table above
         *     referenced by the block reference `2c7cfa`, you could send the following
         *     headers:
         *
         *     - `Operation`: `append`
         *     - `TargetType`: `block`
         *     - `Target`: `2c7cfa`
         *     - `Content-Type`: `application/json`
         *     - with the request body: `[["Chicago, IL", "16"]]`
         *
         *     The use of a `Content-Type` of `application/json` allows the API
         *     to infer that member of your array represents rows and columns of your
         *     to append to the referenced table.  You can of course just use a
         *     `Content-Type` of `text/markdown`, but in such a case you'll have to
         *     format your table row manually instead of letting the library figure
         *     it out for you.
         *
         *     You also have the option of using `prepend` (in which case, your new
         *     row would be the first -- right below the table heading) or `replace` (in which
         *     case all rows except the table heading would be replaced by the new row(s)
         *     you supplied).
         *
         *     ## Setting a Frontmatter Field
         *
         *     If you wanted to set the frontmatter field `alpha` to `2`, you could
         *     send the following headers:
         *
         *     - `Operation`: `replace`
         *     - `TargetType`: `frontmatter`
         *     - `Target`: `beep`
         *     - with the request body `2`
         *
         *     If you're setting a frontmatter field that might not already exist
         *     you may want to use the `Create-Target-If-Missing` header so the
         *     new frontmatter field is created and set to your specified value
         *     if it doesn't already exist.
         *
         *     You may find using a `Content-Type` of `application/json` to be
         *     particularly useful in the case of frontmatter since frontmatter
         *     fields' values are JSON data, and the API can be smarter about
         *     interpreting yoru `prepend` or `append` requests if you specify
         *     your data as JSON (particularly when appending, for example,
         *     list items).
         *
         */
        patch: {
            parameters: {
                query?: never;
                header: {
                    /** @description Patch operation to perform */
                    Operation: "append" | "prepend" | "replace";
                    /** @description Type of target to patch */
                    "Target-Type": "heading" | "block" | "frontmatter";
                    /** @description Delimiter to use for nested targets (i.e. Headings) */
                    "Target-Delimiter"?: string;
                    /** @description Target to patch; this value can be URL-Encoded and *must*
                     *     be URL-Encoded if it includes non-ASCII characters.
                     *      */
                    Target: string;
                    /** @description Trim whitespace from Target before applying patch? */
                    "Trim-Target-Whitespace"?: "true" | "false";
                };
                path: {
                    /** @description Path to the relevant file (relative to your vault root).
                     *      */
                    filename: string;
                };
                cookie?: never;
            };
            /** @description Content you would like to insert. */
            requestBody: {
                content: {
                    "application/json": string;
                    "text/markdown": string;
                };
            };
            responses: {
                /** @description Success */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Bad Request; see response message for details. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
                /** @description Does not exist */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
                /** @description Your path references a directory instead of a file; this request method is valid only for updating files.
                 *      */
                405: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
            };
        };
        trace?: never;
    };
    "/vault/{pathToDirectory}/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List files that exist in the specified directory.
         *      */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Path to list files from (relative to your vault root).  Note that empty directories will not be returned.
                     *
                     *     Note: this particular interactive tool requires that you provide an argument for this field, but the API itself will allow you to list the root folder of your vault. If you would like to try listing content in the root of your vault using this interactive tool, use the above "List files that exist in the root of your vault" form above.
                     *      */
                    pathToDirectory: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Success */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            files?: string[];
                        };
                    };
                };
                /** @description Directory does not exist */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Error"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        Error: {
            /**
             * @description A 5-digit error code uniquely identifying this particular type of error.
             *
             * @example 40149
             */
            errorCode?: number;
            /**
             * @description Message describing the error.
             * @example A brief description of the error.
             */
            message?: string;
        };
        NoteJson: {
            content: string;
            frontmatter: Record<string, never>;
            path: string;
            stat: {
                ctime: number;
                mtime: number;
                size: number;
            };
            tags: string[];
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export type operations = Record<string, never>;
